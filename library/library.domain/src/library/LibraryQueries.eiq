package library

import "library"

// ***** relationships ********


/*
 * CW is the coauthor of W (they share the same book and CW != W) 
 */
pattern coAuthorsOfWriter(W : Writer, CW : Writer) {
	Book(B);
	Writer.books(W, B);
	Writer.books(CW, B);
	W != CW;
}

/*
 * The name of the writer W is N (first name and last name are concatenated)
 */
pattern writerName(W : Writer, N) {
	Writer.firstName(W, FN);
	Writer.lastName(W, LN);
	N == eval(FN + " " + LN);
}

/*
 * Category C has the most books in the Library L.
 */
pattern mostPopularBookCategory(L : Library, C : BookCategory) = {
	Library(L);
	neg find moreBooksInCategoryThan(_Cx, C);
}
 
/*
 * There are more books with category C1 than books with category C2. 
 */
pattern moreBooksInCategoryThan(C1 : BookCategory, C2 : BookCategory) {
	N == count find categoryOfBook(C1, _B1);
	M == count find categoryOfBook(C2, _B2);
	check(N > M);
} 

pattern categoryOfBook(c : BookCategory, b : Book) {
	Book.bookCategory(b, c);
}

/*
 * The "own" books of writer, i.e. the ones that have only w as the author.
 */
pattern ownBooksOfWriter(W : Writer, B : Book) {
	Writer.books(W, B);
	find numberOfWriters(B, 1);
} 

/*
 * All of the (transitive) citations of Book b1 contain Book b2.
 */
pattern allBookCitations(B1 : Book, B2 : Book) {
	find bookCitation+(B1, B2);
}

/*
 * Book ref is contained in the set of books that (transitively) reference Book b. 
 */
@Edge(source = B, target = Ref, label = "ref+")
@Format(lineStyle = "dashed")
pattern allReferencesTo(B: Book, Ref: Book){
	find bookCitation+(Ref, B);
}

/*
 * Book b1 cites Book b2.
 */
@Edge(source = B1, target = B2, label = "cites")
pattern bookCitation(B1 : Book, B2 : Book) {
	Book.citations(B1, B2);
}

/*
 * Writer w1 is influenced by w2, since he wrote some book
 * that (indirectly or directly) references one of w2's works.
 */
@Edge(source = W1, target = W2, label = "influencedBy")
@Format(lineColor = "#ff0000")
pattern influencedBy(W1: Writer, W2: Writer) {
	Book.writers(B1, W1);
	Book.writers(B2, W2);
	find allReferencesTo(B2, B1);
}

// ************* numbers **********

/*
 * The average number of coauthors per book of a writer is 
 * the number of coauthors divided by the number of books.  
 */
pattern averageNumberOfCoauthorsPerBook(W : Writer, A) {
	NumOfBooks == count find writerOfBook(_B, W);
	NumOfCoAuthors == count find coAuthorsOfWriter(W, _CW);
	A == eval(if (NumOfBooks == 0) 0 else NumOfCoAuthors.doubleValue / NumOfBooks.doubleValue);
}

/*
 * The number of (transitive) citations of Book B1 is N.
 */
pattern numberOfCitations(B1 : Book, N) {
	N == count find allBookCitations(B1, _B2);
}

/*
 * The number of the books of Writer W is N.  
 */
pattern numberOfBooksOfWriter(W : Writer, N) {
	N == count find bookOfWriter(W, _B);
}

//@Item(item = B, label = "$B.title$ [$N2$]")
// TODO: this seems to introduce a weird bug
pattern numberOfWriters(B : Book, N) {
	N == count find writerOfBook(B, _W);
}

pattern writerOfBook(B : Book, W : Writer) {
	Book.writers(B, W);
}

@Edge(source = W, target = B, label = "author")
@QueryExplorer(display = true)
pattern bookOfWriter(W : Writer, B : Book) {
	Writer.books(W, B);
}


/*
 * validation stuff
 */
 /*
 * A "suspicious" book is one that:
 *  - is empty (missing some important field)
 *  - is weird (it transitively cites itself)
 */
pattern suspiciousBook(L:Library, B: Book) {
	Library.books(L,B);
	find emptyBook(B);
} 
or {
	Library.books(L,B);
	find weirdBook(B);
}

pattern emptyBook(B: Book) {
	Book.title(B, T);
	check((T as String).length == 0); // works well
	//check(T.length == 0); // doesn't work (?)
} 
or {
//	Book.numberOfWriters(B,0);// this wreaks havoc too
 	find numberOfWriters(B,0);
}

private pattern weirdBook(B : Book) {
	find allBookCitations(B, B);
}